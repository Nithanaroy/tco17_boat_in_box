<meta name="robots" content="noindex">
<html>

<head>
    <meta charset="utf-8">
    <title>Boat in a box</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
        crossorigin="anonymous" />
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN"
        crossorigin="anonymous" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" />
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
        }
        
        html,
        body,
        #wrapper,
        .full-screen-page {
            height: 100%;
        }
        
        #wrapper {}
        
        #alert-container {
            position: absolute;
            top: 1rem;
            text-align: center;
            width: 100%;
            /* highest of all */
            z-index: 405;
        }
        
        #alert-container .alert {
            display: inline-block;
            margin-bottom: 0;
        }
        
        button {
            background: #595A53;
            color: #C8C8C7;
            border: none;
        }
        
        .container-fluid {
            padding-left: 0;
            padding-right: 0;
        }
        
        bb-home-page {
            display: flex;
            flex-direction: column;
        }
        
        #top-header {
            background: #373833;
            padding: 1rem 4rem;
        }
        
        #left-nav {
            position: absolute;
            top: 7rem;
            left: 4rem;
            z-index: 402;
            /* 2 more than leaflet map */
        }
        
        #left-nav ul {
            padding: 0;
            box-shadow: 0 0 10px #000;
        }
        
        #left-nav li {
            list-style: none;
            background: #202123;
            width: 5rem;
            height: 5rem;
            color: #E1D1A6;
            text-align: center;
            line-height: 5rem;
            border-bottom: 1px solid #2F3437;
        }
        
        #left-nav li:last-child {
            border-bottom: none;
        }
        
        #left-nav li:hover {
            background: #17181A;
            cursor: pointer;
        }
        
        #left-nav li.selected {
            background: #17181A;
        }
        
        #ship-count {
            position: absolute;
            bottom: 10rem;
            left: 4rem;
            background: #202123;
            padding: 1rem 0.5rem;
            box-shadow: 0 0 10px #000;
            border-radius: 2px;
            z-index: 402;
            /* 2 more than leaflet map */
        }
        
        #ship-count h2 {
            color: #FFF;
            margin-bottom: 0;
            margin-top: 0;
        }
        
        #map-container {
            background: #131313;
            flex-grow: 1;
        }
        
        #timeline table {
            width: 100%;
        }
        
        #timeline table tr:first-child {
            text-align: center;
            background: #202123;
            font-size: 0.5rem;
            color: #475256;
            border-top: 1px solid #2F3436;
            border-bottom: 1px solid #2F3436;
        }
        
        #timeline table tr:first-child td {
            padding: 0.75rem;
        }
        
        #timeline table tr:nth-child(2) {
            background: #17181A;
        }
        
        #timeline table tr:nth-child(2) td {
            height: 5rem;
        }
        
        #timeline table tr:nth-child(2) td div {
            border-right: 1px solid #1D1E20;
            height: 100%;
            padding: 0;
        }
        
        #timeline #scrubber {
            /* 0 hours to 24 hours = 25 cells. We want the scrubber to start from middle of first cell to middle of last cell */
            /* i.e. width = 24 / 25 * 100% = 96% */
            width: 96%;
            height: 3px;
            background: #485357;
            /* half of #timeline table tr:nth-child(2) height */
            transform: translateY(-2.5rem);
            /* detach it from its parent */
            position: absolute;
            /* Start scrubber from 1/2 of first cell, i.e. 0.5 / 25 * 100% = 2% */
            left: 2%;
            cursor: move;
        }
        
        #timeline #progress-mark {
            position: absolute;
            width: 1.5rem;
            height: 1.5rem;
            background: #E8D7AB;
            border-radius: 1rem;
            transform: translate(-0.75rem, -0.75rem);
            left: 0;
        }
        
        .leaflet-tile {
            border: solid #353737 1px;
        }
        
        .leaflet-tile td {
            border-right: solid #353737 1px;
            border-bottom: solid #353737 1px;
        }
        
        #shipVisualCue {
            position: absolute;
            font-size: 2rem;
            border: dashed 1px #FFF;
            background-color: rgba(20, 40, 29, 0.5);
            padding: 1rem;
            color: #E1D1A6;
            display: none;
            /* highest of all */
            z-index: 405;
            cursor: pointer;
            pointer-events: none;
        }
        
        #ship-info {
            position: absolute;
            width: 35rem;
            /* highest of all */
            z-index: 405;
            color: #C8C8C8;
            font-size: 10px;
        }
        
        #ship-info .col-sm-6,
        #ship-info .col-sm-11 {
            padding: 0;
        }
        
        #ship-info .panel-heading {
            border-bottom: 1px solid #2F3437;
        }
        
        #ship-info .panel,
        #ship-info .panel-footer {
            background: #202123;
        }
        
        #ship-info .panel-title {
            font-size: 2rem;
            margin: 1rem 0;
            font-weight: normal;
        }
        
        #ship-info label {
            font-weight: normal;
        }
        
        #ship-info .form-control {
            background: #2C2D30;
            color: #6F7072;
            border: none;
            font-size: 1rem;
            height: 2.5rem;
        }
        
        #ship-info .panel-footer {
            border-top: 1px solid #2F3437;
            margin-bottom: 1rem;
        }
        
        #ship-info .panel-footer button {
            background: #527E43;
            font-size: 1rem;
        }
        
        #ship-info .close span {
            color: #485357;
        }
    </style>
</head>

<body>
    <div id="wrapper" class="container-fluid"></div>
    <script id="app-template" type="text/stache">
        <bb-home-page class="full-screen-page"></bb-home-page>
    </script>
    <script id="alert-template" type="text/stache">
        {{#if showAlert}}
        <div id="alert-container">
            <div class="alert alert-info" role="alert">
                <!--<button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>-->
                <p>{{alertMsg}}</p>
            </div>
        </div>
        {{/if}}
    </script>
    <script id="home-template" type="text/stache">
        <bb-alert {(alert-msg)}="alertMsg" {(show-alert)}="alertMsgVisible"></bb-alert>
        <!-- Ideally should be in app template level -->
        <header id="top-header">
            <button class="btn-sm" style="margin-right: 1rem;">OPEN</button>
            <button class="btn-sm">SAVE</button>
        </header>
        <div id="left-nav">
            <ul>
                <li title="Add Ship" ($click)="addShipBtnClick()" class="{{#eq leftNavSelectedIndex 1}}selected{{/eq}}">
                    <i class="fa fa-ship" aria-hidden="true"></i>
                </li>
                <li title="Add AIS" class="{{#eq leftNavSelectedIndex 2}}selected{{/eq}}">
                    <i class="fa fa-envelope" aria-hidden="true"></i>
                </li>
                <li title="Remove this tool" class="{{#eq leftNavSelectedIndex 3}}selected{{/eq}}">
                    <i class="fa fa-minus-square" aria-hidden="true"></i>
                </li>
            </ul>
        </div>
        <div id="ship-count">
            <table>
                <tr>
                    <td rowspan="2" style="color: #E1D1A6; font-size: 2rem;">
                        <i class="fa fa-ship" aria-hidden="true" style="margin-right: 1rem;">
                        </td>
                    <td><h2>{{totalShips}}</h2></td>
                </tr>
                <tr>
                    <td style="color: #383F42; font-size: 0.5rem;">Ships Total</td>
                </tr>
            </table>
        </div>

        <div id="map-container"></div>
        <div id="timeline">
            <table>
                <tr>
                    <td style="max-width: 165px; text-align: left; color: #AEAEAF; font-size: 1.3rem;">TIMELINE VIEW</td>
                    {{#times}}
                    <td>{{.}}</td>
                    {{/times}}
                </tr>
                <tr>
                    <td></td>
                    {{#times}}
                    <td>
                        <div class="col-sm-6"></div>
                    </td>
                    {{/times}}
                </tr>
                <tr>
                    <td></td>
                    <td colspan="25" style="position: relative;">
                        <div id="scrubber">
                            <div id="progress-mark" ($mousedown)="moveScrubber(%element, %event)"></div>
                        </div>
                    </td>
                </tr>
            </table>
        </div>
        
        <div id="shipVisualCue" {{#if shipCueEnabled}}style="display: block;"{{/if}}>
            <i class="fa fa-ship" aria-hidden="true"></i>
        </div>
        <div id="ship-info" style="top: {{shipInfoPos.top}}px; left: {{shipInfoPos.left}}px;">
            <div class="panel">
                <div class="panel-heading">
                    <button type="button" class="close" aria-label="Close" ($click)="hideShipInfo()"><span aria-hidden="true">&times;</span></button>
                    <h3 class="panel-title">SHIP INFORMATION</h3>
                </div>
                <div class="panel-body">
                    <p>
                        <span>{{{coordinateFormatter(ship.lat, true)}}}</span> ; <span>{{{coordinateFormatter(ship.lng, false)}}}</span>
                    </p>
                    <div class="form-group">
                        <label for="ship-name">SHIP NAME</label>
                        <input type="text" class="form-control" id="ship-name" placeholder="Enter ship name here" {($value)}="ship.name">
                    </div>
                    <div class="form-group col-sm-6">
                        <div class="col-sm-11">
                            <label for="ship-course">COURSE</label>
                            <div style="display: flex;">
                                <input type="text" class="form-control" id="ship-course" placeholder="Ship course" style="flex: 1;" {($value)}="ship.course">
                                <span style="margin-left: 0.5rem; line-height: 2.5rem; vertical-align: middle;"> <sup>o</sup>Degree</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-group col-sm-6">
                        <div class="col-sm-11">
                            <label for="ship-speed">SPEED</label>
                            <div style="display: flex;">
                                <input type="text" class="form-control" id="ship-speed" placeholder="Ship speed" style="flex: 1;" {($value)}="ship.speed">
                                <span style="margin-left: 0.5rem; line-height: 2.5rem; vertical-align: middle;"> Knots</span>
                            </div>
                        </div>
                    </div>
                    <div class="clearfix"></div>
                </div>
                <div class="panel-footer">
                    <button class="btn-sm btn-success" ($click)="saveShip()">SAVE</button>
                    <button class="btn-sm btn-success" ($click)="wayPointBtnClick()">WAYPOINT</button>
                    <button class="btn-sm btn-success">AIS MESSAGE</button>
                </div>
            </div>
        </div>
    </script>
    <script src="https://unpkg.com/can/dist/global/can.all.js"></script>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
        crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
            crossorigin="anonymous"></script>
            <script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"></script>
            <script>
                let mymap = null; // global reference to leaflet map
                let shipMarker = null; // global reference to ship marker to animate on map
                let mapDrawings = [];

                /* Fixtures */
                let shipsStore = can.fixture.store([]);
                can.fixture("/api/ship", shipsStore);
                can.fixture.delay = 1000;

                /* Models */
                const DEFAULT_SPEED = 10;
                const KNOTS_TO_KM = 1.852;
                let WayPointModel = can.DefineMap.extend({
                    lat: "number",
                    lng: "number",
                    segmentLength: "number", // distance to previous way point
                    speed: {
                        type: "number",
                        value: DEFAULT_SPEED
                    }
                });
                let ShipModel = can.DefineMap.extend({
                    id: "number",
                    name: "string",
                    course: {
                        "type": "number",
                        "value": 0
                    },
                    speed: {
                        "type": "number",
                        "value": DEFAULT_SPEED
                    },
                    lat: "number",
                    lng: "number",
                    waypoints: {
                        "Type": can.DefineList.extend({
                            "Map": WayPointModel
                        }),
                        "value": []
                    },
                    action: "string" // empty string, waypoint, endpoint
                });
                ShipModel.List = can.DefineList.extend({
                    "Map": ShipModel
                });
                can.connect.baseMap({
                    "idProp": "id",
                    "Map": ShipModel,
                    "List": ShipModel.List,
                    "url": "/api/ship/",
                    "name": "Ship"
                });
                window.ShipModel = ShipModel; // TODO: To remove

                /* Components */
                let AppViewModel = can.DefineMap;
                let HomeViewModel = can.DefineMap.extend({
                    mapRef: "*",
                    componentInserted: function () {
                        this.initializeMap();
                        this.subscribeToMapEvents();
                    },
                    initializeMap: function () {
                        var map = L.map('map-container', {
                            zoomControl: false
                        }).setView([17.937107, -76.221486], 7);
                        L.tileLayer(
                            'https://api.mapbox.com/styles/v1/mapbox/dark-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1Ijoibml0aGFuYXJveSIsImEiOiJVTlQ0bUtJIn0.xHgUVf3z6KU1IociPuP-5g', {
                                attribution: '',
                                maxZoom: 18,

                            }).addTo(map);
                        this.mapRef = map;
                        mymap = map;
                        shipMarker = L.marker({
                            lat: 0,
                            lng: 0
                        }, {
                            opacity: 0
                        }).addTo(map);
                    },
                    subscribeToMapEvents: function () {
                        const self = this;
                        mymap.on("click", function (event) {
                            self.onMapClick.call(self, event);
                        });
                    },
                    handleAddingShip: function (event) {
                        const self = this;
                        this.leftNavSelectedIndex = 0;
                        this.shipCueEnabled = false;
                        this.ship = new ShipModel({
                            lat: event.latlng.lat,
                            lng: event.latlng.lng
                        });
                        self.alertMsg = "Saving ship, please wait";
                        this.ship.save().then(function (ship) {
                            self.alertMsgVisible = false;
                            L.marker(event.latlng, {
                                "shipId": ship.id // save ship ID along with marker
                            }).on("click", function (event) {
                                self.shipClicked.call(self, event);
                            }).addTo(mymap);
                            self.shipInfoPos.left = event.originalEvent.clientX;
                            self.shipInfoPos.top = event.originalEvent.clientY;
                        }).catch(handleErrors);
                    },
                    handleAddingEndpoint: function (event) {
                        const self = this;
                        mapDrawings.push(L.marker(event.latlng).on("click", function (event) {
                            self.endPointClicked.call(self, event);
                        }).addTo(mymap));
                        this.ship.waypoints.push(new WayPointModel({
                            lat: event.latlng.lat,
                            lng: event.latlng.lng
                        }));
                        this.ship.action = "waypoint";
                        console.log("end point added");
                    },
                    handleAddingWaypoint: function (event) {
                        mapDrawings.push(L.marker(event.latlng).addTo(mymap));
                        // Add this as the last but one point. The end point is added already
                        let waypointIndex = this.ship.waypoints.length - 1;
                        this.ship.waypoints.splice(waypointIndex, 0, new WayPointModel({
                            lat: event.latlng.lat,
                            lng: event.latlng.lng
                        }));
                        this.ship.waypoints[waypointIndex].segmentLength = this.computeSegmentLength(
                            waypointIndex - 1,
                            waypointIndex);
                        this.ship.save().catch(handleErrors);
                        console.log("way point added");
                    },
                    computeSegmentLength: function (fromIndex, toIndex) {
                        let from;
                        const to = this.ship.waypoints[toIndex];
                        if (fromIndex === -1) {
                            from = this.ship; // ship has the starting co-ordinates
                        } else {
                            from = this.ship.waypoints[fromIndex];
                        }
                        return distanceBetweenCoords(from.lat, to.lat, from.lng, to.lng);
                    },
                    endPointClicked: function (event) {
                        const self = this;
                        const endPointIndex = this.ship.waypoints.length - 1;
                        let segmentLength = this.computeSegmentLength(endPointIndex - 1, endPointIndex);
                        this.ship.waypoints[endPointIndex].segmentLength = segmentLength;
                        this.ship.action = "complete"; // completed adding way points
                        this.alertMsg = "Saving scenario"
                        this.ship.save().then(function (ship) {
                            self.alertMsgVisible = false;
                            self.plotRoute();
                        }).catch(handleErrors);
                    },
                    loadScenario: function () {
                        this.hideShipMarker();
                        this.resetScrubber();
                        this.plotWayPoints();
                        if (this.ship.action === "complete") {
                            this.plotRoute();
                        }
                    },
                    shipClicked: function (event) {
                        const self = this;
                        const shipId = event.target.options.shipId;
                        this.alertMsg = "Fetching ship info...";
                        ShipModel.get({
                            id: shipId
                        }).then(function (ship) {
                            self.alertMsgVisible = false;
                            self.ship = ship;
                            self.loadScenario();
                            self.shipInfoPos.left = event.originalEvent.clientX;
                            self.shipInfoPos.top = event.originalEvent.clientY;
                        }).catch(handleErrors);
                    },
                    cleanUp: function (event) {
                        this.hideShipMarker();

                        // remove ship scenario
                        while (mapDrawings.length > 0) {
                            mapDrawings.pop().removeFrom(mymap);
                        }

                        // reset selected ship
                        this.ship = null;

                        this.resetScrubber();
                    },
                    hideShipMarker: function () {
                        shipMarker.setOpacity(0);
                    },
                    resetScrubber: function () {
                        document.getElementById("progress-mark").style.left = 0;
                        this.scrubberMarkPos = 0;
                    },
                    onMapClick: function (event) {
                        if (this.leftNavSelectedIndex === 1) {
                            this.handleAddingShip(event);
                        } else if (this.ship && this.ship.action === "waypoint") {
                            this.handleAddingWaypoint(event);
                        } else if (this.ship && this.ship.action === "endpoint") {
                            this.handleAddingEndpoint(event);
                        } else {
                            this.cleanUp(event)
                        }
                    },
                    moveShip: function (percentDayComplete) {
                        let timeTravelled = percentDayComplete * 24 / 100;
                        let shipSpeed = 10 * KNOTS_TO_KM;
                        let distanceTravelled = shipSpeed * timeTravelled;
                        let totalLength = 0,
                            i = 0;
                        for (; i < this.ship.waypoints.length; i++) {
                            totalLength += this.ship.waypoints[i].segmentLength;
                            if (distanceTravelled < totalLength) {
                                break;
                            }
                        }
                        let nearestSegmentAccLength = totalLength - this.ship.waypoints[i].segmentLength;
                        let distanceTravelledOnLastSegment = distanceTravelled - nearestSegmentAccLength;
                        let p1 = this.ship.waypoints[i - 1] || this.ship;
                        let p2 = this.ship.waypoints[i];
                        let segmentSlope = (p2.lat - p1.lat) / (p2.lng - p1.lng);
                        let angle = Math.atan(segmentSlope);
                        // Thanks to http://gis.stackexchange.com/a/2964/85044
                        // let shipx = (distanceTravelledOnLastSegment * Math.cos(angle)) / (111.111 * Math.cos(
                        //     p1.lat * Math.PI / 180)) + p1.lng;
                        let shipx = (distanceTravelledOnLastSegment * Math.cos(angle)) / 111.111 + p1.lng;
                        let shipy = distanceTravelledOnLastSegment * Math.sin(angle) / 111.111 + p1.lat;
                        shipMarker.setLatLng({
                            lat: shipy,
                            lng: shipx
                        }).setOpacity(1);
                    },
                    plotRoute: function () {
                        const latlngs = [
                            [this.ship.lat, this.ship.lng]
                        ].concat(this.ship.waypoints.get().map(p => [
                            p.lat, p.lng
                        ]));
                        mapDrawings.push(L.polyline(latlngs, {
                            color: 'red',
                            dashArray: "5,5",
                            weight: 1
                        }).addTo(mymap));
                    },
                    plotWayPoints: function () {
                        this.ship.waypoints.forEach(p => {
                            mapDrawings.push(L.marker({
                                lat: p.lat,
                                lng: p.lng
                            }).addTo(mymap));
                        });
                    },
                    moveScrubber: function (el, downEvent) {
                        const self = this;

                        if (self.ship == null || typeof self.ship.id === "undefined") {
                            self.alertMsg = "Select a ship to see its journey using timeline";
                            return;
                        }

                        if (self.ship.waypoints.length == 0) {
                            self.alertMsg =
                                "Add some waypoints for this ship to see its journey using timeline";
                            return;
                        }

                        let maxDragDistance = el.parentElement.clientWidth;
                        let dragStartXAt = downEvent.clientX;
                        let prevMarkPos = self.scrubberMarkPos;
                        // Thanks to http://stackoverflow.com/a/8933562/1585523 for the idea
                        document.body.onmousemove = function (moveEvent) {
                            let dragAmount = ((moveEvent.clientX - dragStartXAt) / maxDragDistance *
                                100) + prevMarkPos;
                            if (dragAmount >= 0 && dragAmount <= 100) {
                                el.style.left = dragAmount + "%";
                                debounce(function () {
                                    self.moveShip(dragAmount);
                                }, 150)();
                            }
                        }
                        document.body.onmouseup = function () {
                            self.scrubberMarkPos = parseFloat(el.style.left);
                            document.body.onmousemove = document.body.onmouseup = null;
                        }
                    },
                    times: {
                        value: function () {
                            times = [];
                            for (let i = 0; i < 10; i++) {
                                times.push(`0${i}:00`);
                            }
                            for (let i = 10; i < 25; i++) {
                                times.push(`${i}:00`);
                            }
                            return times;
                        }
                    },
                    leftNavSelectedIndex: {
                        value: 0
                    },
                    shipCueEnabled: {
                        value: false
                    },
                    shipInfoPos: {
                        value: {
                            top: -999,
                            left: -999
                        }
                    },
                    ship: {
                        Type: ShipModel,
                        Value: ShipModel
                    },
                    totalShips: {
                        type: "number",
                        value: 0,
                        get: function (lastItemSet, resolve) {
                            // TODO: Does not update on saving new ships
                            ShipModel.getList().then(function (ships) {
                                resolve(ships.length);
                            }).catch(handleErrors);
                        }
                    },
                    scrubberMarkPos: {
                        type: "number",
                        value: 0
                    },
                    alertMsg: {
                        "type": "string",
                        "value": null
                    },
                    alertMsgVisible: {
                        "type": "boolean",
                        "value": false
                    },
                    hideShipInfo: function () {
                        this.shipInfoPos = {
                            top: -999,
                            left: -999
                        };
                    },
                    addShipBtnClick: function addShipBtnClick() {
                        this.leftNavSelectedIndex = 1;
                        this.shipCueEnabled = true;
                    },
                    wayPointBtnClick: function () {
                        this.ship.action = "endpoint";
                        this.hideShipInfo();
                    },
                    saveShip: function () {
                        const self = this;
                        this.ship.save().then(function () {
                            self.alertMsg = "Saved ship successfully";
                        }).catch(handleErrors);
                    }
                });

                can.Component.extend({
                    tag: "bb-alert",
                    view: can.stache.from("alert-template"),
                    viewModel: {
                        alertMsg: {
                            "type": "string",
                            "value": null,
                            "set": function (newMsg) {
                                const self = this;
                                if (newMsg && newMsg.length > 0) {
                                    self.showAlert = true;
                                    window.setTimeout(function () {
                                        self.showAlert = false;
                                        self.alertMsg = null;
                                    }, 5000);
                                }
                                return newMsg;
                            }
                        },
                        showAlert: {
                            "type": "boolean",
                            "value": function () {
                                return this.alertMsg && this.alertMsg.length > 0;
                            }
                        }
                    },
                    "events": {
                        "{viewModel} alertMsg": function (viewModel, event, newMsg, oldMsg) {
                            const self = this;
                            if (newMsg && newMsg.length > 0) {
                                self.viewModel.showAlert = true;
                                window.setTimeout(function () {
                                    self.viewModel.showAlert = false;
                                    self.viewModel.alertMsg = null;
                                }, 2000);
                            }
                        }
                    }
                });

                can.Component.extend({
                    "tag": "bb-home-page",
                    "view": can.stache.from('home-template'),
                    "viewModel": HomeViewModel,
                    "events": {
                        inserted: function componentInserted() {
                            this.viewModel.componentInserted();
                        },
                        "{viewModel} shipCueEnabled": function (viewModel, event, shipCueVisible, oldVal) {
                            if (shipCueVisible) {
                                $("#map-container").mousemove(function (event) {
                                    shipVisualCue.css({
                                        "left": event.clientX,
                                        "top": event.clientY
                                    });
                                });
                            } else {
                                $("#map-container").unbind("mousemove");
                            }
                        },
                        "{viewModel} ship": function (viewModel, event, newShip, oldShip) {
                            if (newShip == null || typeof newShip.id === "undefined") {
                                this.viewModel.hideShipInfo();
                            }
                        }
                    },
                    "helpers": {
                        /**
                         * Converts decimals to degrees, minutes and seconds format
                         * Source: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#Coordinate_format_conversion
                         */
                        coordinateFormatter: function (decimalDegrees, isLat) {
                            const degrees = Math.floor(decimalDegrees);
                            const minutes = Math.floor(60 * (decimalDegrees - degrees));
                            const seconds = Math.round(3600 * (decimalDegrees - degrees) - (60 * minutes));
                            let direction = "N";
                            if (isLat) {
                                if (decimalDegrees < 0) {
                                    direction = "S";
                                }
                            } else {
                                if (decimalDegrees < 0) {
                                    direction = "W";
                                } else {
                                    direction = "E";
                                }
                            }
                            return `${Math.abs(degrees)}<sup>o</sup> ${minutes}' ${seconds}" ${direction}`;
                        }
                    }
                });

                function disableMap() {
                    mymap.dragging.disable();
                    mymap.touchZoom.disable();
                    mymap.doubleClickZoom.disable();
                    mymap.scrollWheelZoom.disable();
                    mymap.boxZoom.disable();
                    mymap.keyboard.disable();
                }

                function enableMap() {
                    mymap.dragging.enable();
                    mymap.touchZoom.enable();
                    mymap.doubleClickZoom.enable();
                    mymap.scrollWheelZoom.enable();
                    mymap.boxZoom.enable();
                    mymap.keyboard.enable();
                }

                function handleErrors(err) {
                    alert("Error occurred. Check console");
                    console.error(err);
                }

                // Pasted from: https://davidwalsh.name/javascript-debounce-function
                // Returns a function, that, as long as it continues to be invoked, will not
                // be triggered. The function will be called after it stops being called for
                // N milliseconds. If `immediate` is passed, trigger the function on the
                // leading edge, instead of the trailing.
                function debounce(func, wait, immediate) {
                    var timeout;
                    return function () {
                        var context = this,
                            args = arguments;
                        var later = function () {
                            timeout = null;
                            if (!immediate) func.apply(context, args);
                        };
                        var callNow = immediate && !timeout;
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                        if (callNow) func.apply(context, args);
                    };
                };

                /* return KM distance between two co-ordinates */
                function distanceBetweenCoords(lat1, lat2, lon1, lon2) {
                    // Pasted from http://www.movable-type.co.uk/scripts/latlong.html
                    const R = 6371e3; // metres
                    const lat1Radians = lat1 * (Math.PI / 180);
                    const lat2Radians = lat2 * (Math.PI / 180);
                    const latDiff = (lat2 - lat1) * (Math.PI / 180);
                    const lngDiff = (lon2 - lon1) * (Math.PI / 180);

                    const a = Math.sin(latDiff / 2) * Math.sin(latDiff / 2) + Math.cos(lat1Radians) * Math.cos(
                            lat2Radians) * Math.sin(lngDiff / 2) * Math
                        .sin(lngDiff / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                    return R * c / 1000;
                }

                var template = can.stache.from("app-template");
                var frag = template(new AppViewModel());
                document.getElementById("wrapper").appendChild(frag);

                const shipVisualCue = $("#shipVisualCue");

                console.log(
                    'Map attribution: Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>'
                )
            </script>
</body>

</html>